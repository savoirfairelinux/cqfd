#!/bin/bash
#
# Copyright (C) 2015 Savoir-faire Linux, Inc.
#
# Author: mathieu.audat@savoirfairelinux.com
#

EERROR=1
ESUCCESS=0

PROGNAME=`basename $0`
TOPDIR=`cd $(dirname $0)/..; pwd`

## usage() - print usage on stdin
usage() {
cat << EOF
Usage: $PROGNAME [OPTIONS]

* If you have a .sflproject: $PROGNAME
* If you want to build with a special command: $PROGNAME -b <"CMD">
* If you want default build command: $PROGNAME <OPTIONS>

Options are:
	-m <buildroot | yocto | openwrt>    Model of build system to use.
	-p <build parameter>		    It can be the name of the
                                              configuration file in buildroot
					      or the recipe in yocto.
	-b <build command>		    Specify a build command to pass to
					      docker.
	-g <client_reponame>		    The name of the docker image
					      Default is client_reponame
	-j				    Make an archive out of release
					      files
	-i				    Initialize build container.
EOF
}

# cfg_parser() - parse ini-style config files
# Will parse a ini-style config file, and evaluate it to a bash array.
#   Ref: http://theoldschooldevops.com/2008/02/09/bash-ini-parser/
# arg$1: path to ini file
cfg_parser() {
	# bash 4.3 and later break compatibility
	if [ $BASH_VERSINFO -ge 4 -a ${BASH_VERSINFO[1]} -gt 2 ]; then
		shopt -s compat42
	fi

	ini="$(<$1)"                # read the file
	ini="${ini//[/\[}"          # escape [
	ini="${ini//]/\]}"          # escape ]
	IFS=$'\n' && ini=( ${ini} ) # convert to line-array
	ini=( ${ini[*]//;*/} )      # remove comments with ;
	ini=( ${ini[*]/\    =/=} )  # remove tabs before =
	ini=( ${ini[*]/=\   /=} )   # remove tabs be =
	ini=( ${ini[*]/\ =\ /=} )   # remove anything with a space around =
	ini=( ${ini[*]/#\\[/\}$'\n'cfg.section.} ) # set section prefix
	ini=( ${ini[*]/%\\]/ \(} )  # convert text2function (1)
	ini=( ${ini[*]/=/=\( } )    # convert item to array
	ini=( ${ini[*]/%/ \)} )     # close array parenthesis
	ini=( ${ini[*]/%\\ \)/ \\} ) # the multiline trick
	ini=( ${ini[*]/%\( \)/\(\) \{} ) # convert text2function (2)
	ini=( ${ini[*]/%\} \)/\}} ) # remove extra parenthesis
	ini[0]="" # remove first element
	ini[${#ini[*]} + 1]='}'    # add the last brace
	eval "$(echo "${ini[*]}")" # eval the result
}

## die() - exit when an error occured
# $@ messages and variables shown in the error message
die() {
	echo "Fatal: $@" 1>&2
	exit $EERROR
}

#docker_build() - Initialize build container
# $1 docker image name
docker_build() {
	docker build -t "$1" docker/.
}

## docker_run() - run command in configured container
docker_run() {
	if  [ "$BUILD_DOCKER" = "1" ]; then
		docker_build "$DOCKER_IMG_NAME"
	fi

	docker run --privileged -v "$PROJECT_PATH":/home/builder/src \
	       -v ~/.ssh:/home/builder/.ssh \
	       -v `dirname $SSH_AUTH_SOCK`:/home/builder/.sockets \
	       -it "$DOCKER_IMG_NAME" \
	       /bin/bash -c "groupadd -og $GROUPS -f builders && \
	       useradd -s /bin/bash -u $UID -g $GROUPS builder && \
	       su - builder -c \"cd src/ && $1\""
}

PROJECT_PATH="${PWD%%/sfl}"
BUILD_DOCKER=0
DISTRO_BUILD_PARAM=
DOCKER_IMG_NAME=""
BUILD_MODEL=
DOCKER_FILE="$TOPDIR/sfl/docker/Dockerfile"
SFL_PROJECT="$TOPDIR/.sflproject"
BUILD_CMD=
RELEASE_FILES=
MAKE_ARCHIVE=0

### main ###

# The .sflproject file allows per-project customizations
if [ -f "$SFL_PROJECT" ]; then
	cfg_parser "$SFL_PROJECT"

	# Load customer, build and release settings
	cfg.section.customer
	CUST_CODENAME="$codename"
	CUST_PROJECT="$project"

	cfg.section.build
	BUILD_CMD="$command"

	cfg.section.release
	RELEASE_FILES="$files"
fi

# Compatibility with P_BUILD_CMD or P_RELEASE_FILE
if [ -n "$P_BUILD_CMD" ]; then
	BUILD_CMD=$P_BUILD_CMD
fi

if [ -n "$P_RELEASE_FILES" ]; then
	RELEASE_FILES=$P_RELEASE_FILES
fi

if [ -z "$CUST_CODENAME" -o -z "$CUST_PROJECT" ]; then
        die "No customer codename/project found in .sflproject!"
fi

# This will look like fooinc_reponame
DOCKER_IMG_NAME="${CUST_CODENAME}_${CUST_PROJECT}"

while getopts "ijhp:m:b:g:" OPTION; do
	case "$OPTION" in
	h)
		usage
		exit $ESUCCESS
		;;
	m)
		BUILD_MODEL="$OPTARG"
		;;
	p)
		DISTRO_BUILD_PARAM="$OPTARG"
		;;
	b)
		BUILD_CMD="$OPTARG"
		;;
	g)
		DOCKER_IMG_NAME="$OPTARG"
		;;
	j)
		MAKE_ARCHIVE=1
		;;
	i)
		BUILD_DOCKER=1
		;;
	*)
		die "Unknown parameter $OPTION"
		;;
	esac
done

if [ ! -f "$DOCKER_FILE" ]; then
	die " $DOCKER_FILE not found"
fi

# BUILD_CMD can be taken from Dockerfile or you can choose your own
# with -b
if [ -n "$BUILD_CMD" ]; then
	docker_run "$BUILD_CMD"
else
	if [ -z "$DISTRO_BUILD_PARAM" ]; then
		die "build parameters not specified." \
		    "Use -p to specify a build parameter"
	fi

	case "$BUILD_MODEL" in
	buildroot)
		BUILD_CMD="make clean && make $DISTRO_BUILD_PARAM && make"
		;;

	yocto)
		BUILD_CMD="set -e && \
			source oe-init-build-env build-$DISTRO_BUILD_PARAM && \
			bitbake -f $DISTRO_BUILD_PARAM"
		;;

	openwrt)
		BUILD_CMD="make clean && \
			echo $DISTRO_BUILD_PARAM >.config && \
			make defconfig && \
			make"
		;;
	*)
		die "build model not recognized"
		;;
	esac

	docker_run "$BUILD_CMD"
fi

# Create Release package
if [ "$MAKE_ARCHIVE" = "1" ]; then
	if [ -z "$JOB_NAME" ]; then
		JOB_NAME="local-build"
		BUILD_ID="`date --rfc-3339='date'`"
	fi

	if [ -z "$RELEASE_FILES" ]; then
		die "No files to archive, check release.files in $SFL_PROJECT"
	fi

	for file in $RELEASE_FILES; do
		[ -f $file ] || die "Cannot create release: missing $file"
	done

	RELEASE_PACKAGE=${JOB_NAME}_${BUILD_ID}.tar.xz
	XZ_OPT=-9 tar --transform "s/.*\///g" -cJf \
		$RELEASE_PACKAGE $RELEASE_FILES
fi

exit $ESUCCESS
